\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{noweb}

%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 


%% ** Title

\title{Implémentation de la théorie des types dépendants}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 


\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'upmc,
\end{abstract}

\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

blablawsdsdfsdf

\section{lambda calcul non typé}

En 1936 que Alonzo Church introduit le lambda calcul non typé(citation de church), c'est
un modèle de calcul universel tout comme les machines de Turing. Celui ci repose
sur une syntaxe minimaliste et permet de formaliser le concept d'application 
de fonctions. Il est au coeur de nombreuses recherches dans le domaine de la programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de (citation pierce).

\subsection{Présentation formelle}

\subsubsection{Syntaxe}
Le lambda calcul est composé uniquement de \(\lambda\) termes dont voici la syntaxe

\begin{align*}
  t &::= & \mbox{(lambda terme)} \\
  &|\quad x & \mbox{(variable)} \\
  &|\quad \lambda x. t & \mbox{(abstraction)} \\
  &|\quad t\: t          & \mbox{(application)}
\end{align*}

\begin{example}
  L'abstraction nous permet de construire des fonctions anonymes, par exemple la
  fonction identitée peut etre définie par le lambda terme suivant :
  %
  \[ 
  \lambda x. x
  \]
\end{example}

\subsubsection{Variables libres et variables liées}

Une variable est liée lorsque celle ci est déclarée dans un lambda, dans 
l'exemple précédent x était une variable liée. 
Si la variable n'a pas été déclarée elle sera dite libre. 

\begin{example}
  Dans le terme suivant \(\lambda x.\lambda y.x\:y\:z\) , les variables x et 
  y sont liées tandis que la variable z est libre 
\end{example}

\begin{example}
  Dans le lambda terme \((\lambda x. \lambda y. x\: y)\: y\), la
  variable \(x\) est liée ainsi que la première occurence de la
  variable \(y\). Cependant, la variable \(y\) à l'exterieur des
  parenthèse est libre.
\end{example}

Un des problème introduit par cette représentation des variables est qu'il devient assez compliqué de déterminer si une variable est libre ou non, comme on peut le constater dans l'exemple ci dessus(exemple 3). 

\subsubsection{Les indices de de Bruijn}

Pour palier au problème que nous énoncions précédement, il existe une 
représentation pour les variables liées, les indides de de Bruijn.
Nous allons donc maintenant représenté les variables liées non pas par un 
nom mais par un entier naturel. 
\begin{example}
  Le lambda terme représentant l'identité que l'on ecrivait \(\lambda x.x\) s'écrirat donc maintenant \(\lambda.0\)
\end{example}

  






\end{document}
